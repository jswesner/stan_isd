return(samples)
}
plot(rparetocounts(100, -1.01, 1, 1000))
rparetocounts <- function(n, mu, vreal2, vreal3) {
samples <- numeric(n)
for (i in 1:n) {
if (mu != -1) {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if vreal3^(mu + 1) >= vreal2^(mu + 1)
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <- (u*vreal3^(mu+1) +  (1-u) * vreal2^(mu+1) ) ^ (1/(mu+1))
}
} else {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if log(vreal2) - log(vreal3) <= 0
} else {
samples[i] <- NaN
}
}
}
return(samples)
}
plot(rparetocounts(100, -1.01, 1, 1000))
plot(rparetocounts(100, -1., 1, 1000))
plot(rparetocounts(100, -1, 1, 1000))
plot(rparetocounts(100, -1.2, 1, 1000))
sizeSpectra::rPLB(100, -1.2, 1, 1000)
plot(sizeSpectra::rPLB(100, -1.2, 1, 1000))
plot(rparetocounts(100, -1.2, 1, 1000))
plot(sizeSpectra::rPLB(100, -1.2, 1, 1000))
plot(rparetocounts(100, -1.2, 1, 1000))
plot(sizeSpectra::rPLB(100, -1.2, 1, 1000))
rparetocounts <- function(n, mu, vreal2, vreal3) {
samples <- numeric(n)
for (i in 1:n) {
if (mu != -1) {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if vreal3^(mu + 1) >= vreal2^(mu + 1)
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <- (u*vreal3^(mu+1) +  (1-u) * vreal2^(mu+1) ) ^ (1/(mu+1))
}
} else {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if log(vreal2) - log(vreal3) <= 0
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <-  xmax^u * xmin^(1-u)
}
}
}
return(samples)
}
plot(rparetocounts(100, -1.2, 1, 1000))
plot(rparetocounts(100, -1, 1, 1000))
plot(rparetocounts(100, -1, 1, 1000))
rparetocounts <- function(n, mu, vreal2, vreal3) {
samples <- numeric(n)
for (i in 1:n) {
if (mu != -1) {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if vreal3^(mu + 1) >= vreal2^(mu + 1)
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <- (u*vreal3^(mu+1) +  (1-u) * vreal2^(mu+1) ) ^ (1/(mu+1))
}
} else {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if log(vreal2) - log(vreal3) <= 0
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <-  xmax^u * xmin^(1-u)
}
}
}
return(samples)
}
source("code/pareto_brm.R")
rparetocounts <- function(n, mu, vreal2, vreal3) {
samples <- numeric(n)
for (i in 1:n) {
if (mu != -1) {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if vreal3^(mu + 1) >= vreal2^(mu + 1)
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <- (u*vreal3^(mu+1) +  (1-u) * vreal2^(mu+1) ) ^ (1/(mu+1))
}
} else {
if (vreal2 >= vreal3) {
samples[i] <- NaN  # Set sample to NaN if log(vreal2) - log(vreal3) <= 0
} else {
u <- runif(1, min = 0, max = 1)
samples[i] <-  xmax^u * xmin^(1-u)
}
}
}
return(samples)
}
rparetocounts(10, -1.4, 1, 1000)
rparetocounts(10, -1.4, 0.1, 1000)
rparetocounts(10, -1.4, 0.1, 10)
rparetocounts(100, -1.4, 0.1, 10)
rparetocounts(1000, -1.4, 0.1, 10)
rparetocounts(1000, -1, 0.1, 10)
rparetocounts(1000, -1, 0.1, 10)
rparetocounts(1000, -1.1, 0.1, 10)
rparetocounts(1000, -1, 0.1, 10)
rparetocounts(1000, -1.000001, 0.1, 10)
rparetocounts(1000, -1.000001, 0.1, 10)
sizeSpectra::rPLB(1000, -1, 1, 1000)
sizeSpectra::rPLB(1000, -1, .1, 10)
rparetocounts(1000, -1, 0.1, 10)
source("code/pareto_brm.R")
rparetocounts(1000, -1, 0.1, 10)
rparetocounts(1000, -1, 1, 1000)
rparetocounts(1000, -1.2, 1, 1000)
rparetocounts(1000, -1.9, 1, 1000)
hist(rparetocounts(1000, -1.9, 1, 1000))
hist(rparetocounts(1000, 0, 1, 1000))
hist(rparetocounts(1000, 1, 1, 1000))
hist(rparetocounts(1000, 1.9, 1, 1000))
hist(rparetocounts(1000, 2.9, 1, 1000))
hist(rparetocounts(1000, -7, 1, 1000))
hist(rparetocounts(1000, -1, 1, 1000))
hist(rparetocounts(1000, -2, 1, 1000))
hist(rparetocounts(1000, -2.2, 1, 1000))
hist(rparetocounts(1000, -1.2, 1, 1000))
rparetocounts(1000, -1.2, 1, 1000)
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000).
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000).
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = brm(dw ~ 1,
data = sim_data,
family = paretocounts,
prior = c(prior(normal(-1.2, 0.1), class = "Intercept")))
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000)) %>%
mutate(sample = 1,
vreal2 = 1,
vreal3 = 1000,
vreal1 = 1)
fit_brm = brm(dw ~ 1,
data = sim_data,
family = paretocounts,
prior = c(prior(normal(-1.2, 0.1), class = "Intercept")))
sim_data
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = brm(dw | vreal(counts, xmin, xmax) ~ 1,
data = sim_data,
family = paretocounts,
prior = c(prior(normal(-1.2, 0.1), class = "Intercept")))
paretocounts <- custom_family(
"paretocounts", dpars = c("mu"),
links = c("identity"),
lb = -Inf, ub = Inf,
type = "real", vars = c("vreal1[n]",
"vreal2[n]",
"vreal3[n]"))
stan_funs <- "
real paretocounts_lpdf(real Y, real mu, real vreal1, real vreal2, real vreal3){
if(mu != -1)
return(vreal1*(log((mu+1) / ( vreal3^(mu+1) - vreal2^(mu+1))) + mu*log(Y)));
else
return(vreal1*(log(log(vreal2) - log(vreal3)) + mu*log(Y)));
}
"
stanvars <- stanvar(scode = stan_funs, block = "functions")
sim_data
fit_brm = brm(dw | vreal(counts, xmin, xmax) ~ 1,
data = sim_data,
family = paretocounts)
make_stancode(dw | vreal(counts, xmin, xmax) ~ 1,
data = sim_data,
family = paretocounts)
sim_data = tibble(dw = rparetocounts(1000, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = brm(dw | vreal(counts, xmin, xmax) ~ 1,
data = sim_data,
family = paretocounts,
stanvars = stanvars)
fit_brm
sim_data = tibble(dw = rparetocounts(100, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = update(fit_brm, newdata = sim_data)
fit_brm
sim_data = tibble(dw = rparetocounts(100, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = update(fit_brm, newdata = sim_data)
fit_brm
sim_data = tibble(dw = rparetocounts(300, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
fit_brm = update(fit_brm, newdata = sim_data)
fit_brm
library(tidybayes)
fit_brm$data %>%
add_epred_draws(fit_brm)
log_lik_logitnormal <- function(i, prep) {
mu <- brms::get_dpar(prep, "mu", i = i)
sigma <- brms::get_dpar(prep, "sigma", i = i)
y <- prep$data$Y[i]
dlogitnormal(y, mu, sigma, log = TRUE)
}
dparetocounts <- function(x, mu, vreal2, vreal3) {
if (vreal2 <= 0 || vreal2 >= vreal3)
stop("Parameters out of bounds in dPLB")
if (mu != -1) {
density <- (mu + 1) * (x^(mu+1)) / (vreal3^(mu+1) - vreal2^(mu+1))
} else {
density <- x^(-2) / (vreal2 * log(vreal3/vreal2))
}
density
}
dparetocounts(10, -1.2, 1, 1000)
dparetocounts(10, -1.2, 1, 1000)
dparetocounts(10, -1.2, 1, 1000)
dparetocounts(0.1, -1.2, 1, 1000)
dparetocounts(10, -1.2, 1, 1000)
dparetocounts(1000, -1.2, 1, 1000)
dparetocounts(0.001, -1.2, 1, 1000)
dparetocounts <- function(x, mu, vreal2, vreal3) {
if (vreal2 <= 0 || vreal2 >= vreal3)
stop("Parameters out of bounds in dPLB")
if (x < vreal2 || x > vreal3)
return(0)
if (mu != -1) {
density <- (mu + 1) * (x^(mu+1)) / (vreal3^(mu+1) - vreal2^(mu+1))
} else {
density <- x^(-2) / (vreal2 * log(vreal3/vreal2))
}
density
}
dparetocounts(0.001, -1.2, 1, 1000)
dparetocounts(1, -1.2, 1, 1000)
dparetocounts(1000, -1.2, 1, 1000)
dparetocounts(1001, -1.2, 1, 1000)
log_lik_paretocounts <- function(i, prep) {
mu <- brms::get_dpar(prep, "mu", i = i)
y <- prep$data$Y[i]
dparetocounts(x, mu, vreal2, vreal3)
}
posterior_epred_paretocounts <- function(prep) {
mu <- prep$dpars$mu
return(mu)
}
posterior_predict_paretocounts <- function(i, prep, ...) {
mu <- brms::get_dpar(prep, "mu", i = i)
rparetocounts(prep$ndraws, mu, vreal2, vreal3)
}
posterior_epred_paretocounts <- function(prep) {
mu <- prep$dpars$mu
return(mu)
}
paretocounts <- custom_family(
"paretocounts", dpars = c("mu"),
links = c("identity"),
lb = -Inf, ub = Inf,
type = "real", vars = c("vreal1[n]",
"vreal2[n]",
"vreal3[n]"))
stan_funs <- "
real paretocounts_lpdf(real Y, real mu, real vreal1, real vreal2, real vreal3){
if(mu != -1)
return(vreal1*(log((mu+1) / ( vreal3^(mu+1) - vreal2^(mu+1))) + mu*log(Y)));
else
return(vreal1*(log(log(vreal2) - log(vreal3)) + mu*log(Y)));
}
"
stanvars <- stanvar(scode = stan_funs, block = "functions")
log_lik_paretocounts <- function(i, prep) {
mu <- brms::get_dpar(prep, "mu", i = i)
y <- prep$data$Y[i]
dparetocounts(x, mu, vreal2, vreal3)
}
posterior_predict_paretocounts <- function(i, prep, ...) {
mu <- brms::get_dpar(prep, "mu", i = i)
rparetocounts(prep$ndraws, mu, vreal2, vreal3)
}
posterior_epred_paretocounts <- function(prep) {
mu <- prep$dpars$mu
return(mu)
}
fit2
fit
fit_brm
conditional_effects(fit_brm)
fitted(fit_brm)
install_github("jswesner/isdbayes")
devtools::install_github("jswesner/isdbayes")
devtools::install_github("jswesner/spectrabayes")
library(isdbayes)
rparetocounts()
isdbayes::rparetocounts()
devtools::install_github("jswesner/isdbayes")
devtools::install_github("jswesner/isdbayes")
library(isdbayes)
rparetocounts()
sim_data = tibble(dw = rparetocounts(300, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
library(tidyverse)
library(brms)
library(isdbayes)
sim_data = tibble(dw = rparetocounts(300, -1.2, 1, 1000)) %>%
mutate(sample = 1,
xmin = 1,
xmax = 1000,
counts = 1)
devtools::install_packages("isdbayes")
devtools::install_github("isdbayes")
devtools::install_github("jswesner/isdbayes")
devtools::install_github("jswesner/isdbayes", force = T)
library(isdbayes)
rparetocounts()
library(brms)
library(tidyverse)
library(tidybayes)
library(janitor)
# get data
sim_data = readRDS(file = "data/sim_data.rds") %>%
bind_rows() %>%
rename(true_lambda = lambda,
dw = x)
# load posteriors
recover_sims = readRDS(file = "posteriors/recover_sims_counts.rds")
# median lambdas
posts_medians = recover_sims %>%
group_by(true_lambda) %>%
median_qi(lambda)
# plot isd's --------------------------------------------------------------
# sample dw weighted by density
nsamples = 1000
dat_sims = sim_data %>%
left_join(posts_medians) %>%
group_by(true_lambda, xmax, sample_size) %>%
sample_n(nsamples, weight = counts, replace = T) %>%
select(dw, true_lambda, xmin, xmax, counts, lambda, .lower, .upper)
dat_toplot = dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
arrange(desc(dw)) %>%
mutate(y_order = 1:nsamples - 1,
true_lambda = round(true_lambda, 1)) %>%
ungroup()
# estimate isd line and CrI
dat_split = dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
group_split
xy.PLB = NULL
for(i in 1:length(dat_split)) {
true_lambda = unique(dat_split[[i]]$true_lambda)
# site_id = unique(dat_split[[i]]$site_id)
# year = unique(dat_split[[i]]$year)
xmin = unique(dat_split[[i]]$xmin)
xmax = unique(dat_split[[i]]$xmax)
lambda = unique(dat_split[[i]]$lambda)
.lower = unique(dat_split[[i]]$.lower)
.upper = unique(dat_split[[i]]$.upper)
x.PLB = seq(xmin, xmax,
length=nsamples) # x values to plot PLB
y.PLB = (1 - (x.PLB^(lambda + 1) - (xmin^(lambda+1)))/(xmax^(lambda + 1) - (xmin^(lambda+1))))*nsamples
ymin.PLB = (1 - (x.PLB^(.lower + 1) - (xmin^(.lower+1)))/(xmax^(.lower + 1) - (xmin^(.lower+1))))*nsamples
ymax.PLB = (1 - (x.PLB^(.upper + 1) - (xmin^(.upper+1)))/(xmax^(.upper + 1) - (xmin^(.upper+1))))*nsamples
xy.PLB[[i]] = tibble(dw = x.PLB,
y_order = y.PLB,
ymin = ymin.PLB,
ymax = ymax.PLB,
xmax = xmax,
xmin = xmin) %>%
mutate(true_lambda = true_lambda,
# site_id = site_id,
# year = year,
lambda = lambda)
}
lines_toplot = bind_rows(xy.PLB) %>%
mutate(true_lambda = round(true_lambda, 1)) %>%
mutate(true_lambda = case_when(true_lambda == min(true_lambda) ~ "a) \u03bb = -2",
true_lambda == max(true_lambda) ~ "c) \u03bb = -1.3",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "b) \u03bb = -1.6")) %>%
filter(!is.na(true_lambda))
isd_single_samples_plot = dat_toplot   %>%
mutate(true_lambda = case_when(true_lambda == min(true_lambda) ~ "a) \u03bb = -2",
true_lambda == max(true_lambda) ~ "c) \u03bb = -1.3",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "b) \u03bb = -1.6")) %>%
filter(!is.na(true_lambda)) %>%
ggplot(aes(x = dw, y = y_order/1000, group = true_lambda)) +
geom_point(shape = 21, size = 0.3) +
geom_line(data = lines_toplot ) +
geom_ribbon(data = lines_toplot  ,
aes(ymin = ymin/1000, ymax = ymax/1000), alpha = 0.2) +
scale_x_log10() +
scale_y_log10() +
facet_wrap(~true_lambda) +
theme_default() +
theme(
strip.background = element_blank(),
strip.text = element_text(hjust = 0)) +
labs(y = "Proportion of values \u2265 x",
x = "Individual dry mass (mg)",
color = "") +
guides(color = "none") +
coord_cartesian(ylim = c(1e-04, NA))
isd_single_samples_plot
saveRDS(isd_single_samples_plot, file = "plots/isd_single_samples_plot.rds")
ggsave(isd_single_samples_plot, file = "plots/isd_single_samples_plot.jpg",
width = 7, height = 7, dpi = 400)
lambda_labels = dat_toplot %>%
mutate(letters = case_when(true_lambda == min(true_lambda) ~ "d)",
true_lambda == max(true_lambda) ~ "b)",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "c)")) %>%
filter(!is.na(letters)) %>%
mutate(lambda_value = case_when(true_lambda == min(true_lambda) ~ "\u03bb = -2",
true_lambda == max(true_lambda) ~ "\u03bb = -1.3",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "\u03bb = -1.6")) %>%
filter(!is.na(lambda_value)) %>%
mutate(dw = 2, y_order = 70) %>%
ungroup %>%
distinct(dw, y_order, letters, lambda_value)
isd_single_samples_plot_long = dat_toplot %>%
mutate(letters = case_when(true_lambda == min(true_lambda) ~ "d)",
true_lambda == max(true_lambda) ~ "b)",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "c)")) %>%
filter(!is.na(letters)) %>%
ggplot(aes(x = dw, y = y_order/1000, group = true_lambda)) +
geom_point(shape = 21, size = 0.1) +
geom_line(data = lines_toplot %>%
mutate(letters = case_when(grepl("a", true_lambda) ~ "d)",
grepl("b", true_lambda) ~ "c)",
TRUE ~ "b)")),
linewidth = 0.2) +
geom_ribbon(data = lines_toplot %>%
mutate(letters = case_when(grepl("a", true_lambda) ~ "d)",
grepl("b", true_lambda) ~ "c)",
TRUE ~ "b)"))  ,
aes(ymin = ymin/1000, ymax = ymax/1000), alpha = 0.2) +
geom_text(data = lambda_labels, aes(label = lambda_value),
size = 3) +
scale_x_log10() +
scale_y_log10() +
facet_wrap(~letters, ncol = 1) +
theme_default() +
theme(
strip.background = element_blank(),
strip.text = element_text(hjust = 0)) +
labs(y = "Proportion of values \u2265 x",
x = "Individual dry mass (mg)",
color = "") +
guides(color = "none") +
coord_cartesian(ylim = c(1e-04, NA))
isd_single_samples_plot_long
saveRDS(isd_single_samples_plot_long, file = "plots/isd_single_samples_plot_long.rds")
ggsave(isd_single_samples_plot_long, file = "plots/isd_single_samples_plot_long.jpg",
width = 3, height = 7, dpi = 400)
isd_single_samples_plot_long
sim_data
sim_data %>%
left_join(posts_medians) %>%
group_by(true_lambda, xmax, sample_size) %>%
sample_n(nsamples, weight = counts, replace = T)
dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
arrange(desc(dw))
dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
arrange(desc(dw)) %>%
mutate(y_order = 1:nsamples - 1,
true_lambda = round(true_lambda, 1))
dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
arrange(true_lambda, desc(dw)) %>%
mutate(y_order = 1:nsamples - 1,
true_lambda = round(true_lambda, 1))
dat_toplot = dat_sims %>%
# filter(sample_int %in% c(id)) %>%
group_by(true_lambda) %>%
arrange(true_lambda, desc(dw)) %>%
mutate(y_order = 1:nsamples - 1,
true_lambda = round(true_lambda, 1)) %>%
ungroup()
dat_toplot   %>%
mutate(true_lambda = case_when(true_lambda == min(true_lambda) ~ "a) \u03bb = -2",
true_lambda == max(true_lambda) ~ "c) \u03bb = -1.3",
true_lambda <= -1.55 & true_lambda >= -1.65 ~ "b) \u03bb = -1.6")) %>%
filter(!is.na(true_lambda)) %>%
ggplot(aes(x = dw, y = y_order/1000, group = true_lambda)) +
geom_point(shape = 21, size = 0.3)
